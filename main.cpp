#include <iostream>
#include <stdio.h>
#include "merge_two.h"
#include <fstream>
#include <vector>
#include <ctime>
#include<algorithm>
#include<cstdlib>
//#inlcude <>
#define Iterator_Time 10
using namespace std;
FILE * f_read;
// FILE * f_out;
int main(){


	char filename[200];
	const unsigned int interval = 53;//n_update/n_total==1/interval
	
	unsigned int n_number_original = 0;
	unsigned int n_number_after_remove_redoundency = 0;
	unsigned int n_number_to_update = 0;
	unsigned int n_number_in_tcam = 0;
	unsigned int n_actual[Iterator_Time + 1];
	unsigned int n_move[Iterator_Time + 1];
	unsigned int n_in_Tcam[Iterator_Time + 1];
	unsigned int n_Capability_of_TCAM[Iterator_Time + 1];

	double t_start = 0.0;
	double t_end = 0.0;
	double t_duration[Iterator_Time + 1];

	vector<Node> rule_set_original(0);
	vector<Node> rule_in_TCAM(0);
	vector<Node> rule_to_Update(0);
	vector<int> r(0);
	Graph graph;
	TCAM tcam;
	
	memset(&t_start,0,sizeof(t_start));
	memset(&t_end,0,sizeof(t_end));
	memset(t_duration,0,sizeof(t_duration));
	memset(n_actual,0,sizeof(n_actual));
	memset(n_move,0,sizeof(n_move));
	memset(n_in_Tcam,0,sizeof(n_in_Tcam));
	memset(n_Capability_of_TCAM,0,sizeof(n_Capability_of_TCAM));

//##############################################
	cout <<"The Processing Order"<< endl;
	for (int x = 1; x <= Iterator_Time;x++)
	{
		for (int j = 1;j <= Iterator_Time;j++) {
			cout<<j<<endl;
		
			//##########################################reset the variable to prepare for the next input#######################################################
			r.clear();
			rule_set_original.clear();
			rule_in_TCAM.clear();
			rule_to_Update.clear();

			memset(filename, 0, sizeof(filename));
			sprintf(filename, "E:\\学习\\北邮\\毕业设计\\proj\\filters\\ipc filters\\MyFilters%dk_%d.txt", x, j);
			//##########################################read the rules from the file generated by ClassBench#####################################################
			
			if ((f_read = fopen(filename, "r")) == NULL) {
				printf("The file can not be opened.\n");
				return 0;
			}
			n_number_original = loadrule(f_read, rule_set_original);

			//random_shuffle(rule_set_original.begin(), rule_set_original.end());

			n_number_after_remove_redoundency = remove_redundancy(rule_set_original, n_number_original);
			rule_set_original.resize(n_number_after_remove_redoundency);
			Rule_Set_Split(rule_set_original, rule_in_TCAM, rule_to_Update, interval);
			
			//###############################################initiate the Graph and the TCAM####################################################################
			
			Graph::Capability = n_number_after_remove_redoundency;
			TCAM::Capability = n_number_after_remove_redoundency;
			graph.Graph_Init();
			tcam.TCAM_Init();
			
			//###############################################set the rule_in_TCAM into Graph and TCAM to as the original base###################################
			
			Rule_Set_Into_Graph(graph, rule_in_TCAM, rule_in_TCAM.size());
			Graph_Build(graph);
			//Map_Graph_To_TCAM_Empty_Random(graph, tcam);//随机留空
			Map_Graph_To_TCAM_Empty_Uniform(graph,tcam);//均匀留空
			
			//#################################################iterator process starts##########################################################################

			srand((unsigned int)clock());
			random_shuffle(rule_to_Update.begin(), rule_to_Update.end());
			for (unsigned int i = 0;i<rule_to_Update.size();i++) {
				
					t_start = clock();
					Find_Relevant_Rule(graph, rule_to_Update[i]);
					t_end = clock();
					t_duration[j] = t_duration[j] + ((double)(t_end - t_start))/ CLOCKS_PER_SEC;
					
					if (!Collision_Judge(graph, rule_to_Update[i])){
						unsigned int n = 0;
						t_start = clock();
						n = Collision_Judge_With_Solved(graph,tcam,rule_to_Update[i]);
						t_end = clock();
						t_duration[j] = t_duration[j] + ((double)(t_end - t_start))/ CLOCKS_PER_SEC;
						n_move[j] = n_move[j] + n;
					}
					
					t_start = clock();
					Algorithm_4(graph, tcam, rule_to_Update[i], r);
					t_end = clock();
					t_duration[j] = t_duration[j] + ((double)(t_end - t_start)) / CLOCKS_PER_SEC;
					
					//Graph_Update(graph, tcam, rule_to_Update[i], r);
					//TCAM_Update_2(graph, tcam, rule_to_Update[i], r);
					
					n_actual[j]++;
					n_move[j] = n_move[j] + r.size();
				}

			n_in_Tcam[j] = TCAM::N_current;
			n_Capability_of_TCAM[j] = TCAM::Capability;
			//#################################################check the correctness############################################################################
			
			Correctness_Judge(graph);
		}
		sprintf(filename, "E:\\学习\\北邮\\毕业设计\\proj\\Result_algorithm_4_with_Empty_Last_and_Update_Random_%dk.csv", x);
		ofstream f_out(filename, ios::out);
		//ofstream f_out("E:\\学习\\北邮\\毕业设计\\proj\\Result_algorithm_4_with_Empty_Last_and_Update_Random_old.csv", ios::out);
		f_out << "Order" << "," << "N_Final" << "," << "Capability" << "," << "The Time Cost Per Update/s" << "," << "The Move Frequency Per Update" << endl;
		for (unsigned int i = 1; i <= Iterator_Time; i++) {
			f_out << i << "," << n_in_Tcam[i] << "," << n_Capability_of_TCAM[i] << "," << t_duration[i] / n_actual[i] << "," << n_move[i] * 1.0 / n_actual[i] << endl;
		}
		f_out.close();

		cout << "Order" << "    " << "N_Final" << "     " << "Capability" << "     " << "The Time Cost Per Update/s" << "   " << "The Move Frequency Per Update" << endl;
		for (unsigned int i = 1; i <= Iterator_Time; i++) {
			cout << "  " << i << "\t\t" << n_in_Tcam[i] << "\t\t" << n_Capability_of_TCAM[i] << "\t\t" << t_duration[i] / n_actual[i] << "\t\t" << n_move[i] * 1.0 / n_actual[i] << endl;
		}
	}

	cout << "!!!!!!!!!!!!!!!!!!!!Press Enter To End the Progranmmar!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
	getchar();
	return 0;

}